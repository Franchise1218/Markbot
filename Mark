import json
import pandas as pd
import sqlite3
import random
import subprocess

# Personalized startup message
print(f"\n🤖 Yo, it's Mark! Welcome back, Jose! Let’s get this damn wrestling data rollin’.")

# Connect to SQLite (Creates database if it doesn't exist)
conn = sqlite3.connect("mark_database.db")
cursor = conn.cursor()

# Ensure the DVDs table exists
cursor.execute("""
    CREATE TABLE IF NOT EXISTS dvds (
        id INTEGER PRIMARY KEY,
        disc_number TEXT,
        event_number TEXT,
        date TEXT,
        company TEXT,
        cloud TEXT,
        hard_drive TEXT,
        match_listing TEXT
    )
""")

# Ensure match results table exists for storing scraped events
cursor.execute("""
    CREATE TABLE IF NOT EXISTS match_results (
        id INTEGER PRIMARY KEY,
        event_name TEXT,
        matches TEXT
    )
""")
conn.commit()
conn.close()

# Search History for tracking past queries
search_history = []

# Function to search SQL database with partial matching
def search_sql_data(query):
    global search_history
    search_history.append(query)  # Track past searches

    conn = sqlite3.connect("mark_database.db")
    cursor = conn.cursor()

    cursor.execute("""
        SELECT * FROM dvds WHERE 
        disc_number LIKE ? OR event_number LIKE ? OR company LIKE ? OR match_listing LIKE ? OR cloud LIKE ?
    """, ('%'+query+'%', '%'+query+'%', '%'+query+'%', '%'+query+'%', '%'+query+'%'))

    results = cursor.fetchall()
    conn.close()

    if results:
        response = f"\n📀 **Here you go, boss. Pulled some damn good results for '{query}':**\n"
        response += "\n".join(
            f"🎬 Disc #: {r[1]} | Event #: {r[2]} | Date: {r[3]} | Company: {r[4]} | Cloud: {r[5]} | Matches: {r[7]}"
            for r in results
        )
    else:
        response = f"\n🛑 **Bruh, that weak-ass search ain't got nothing.** Try again."

    # Add some street flavor based on past searches
    if len(search_history) > 3:  
        response += f"\n🧐 **Yo, Jose—you done hit up '{query}' like 3 times. You good, homie?**"
    
    return response

# Function to filter searches (Cloud entries, Disc #, Match Listings)
def search_filtered_data(filter_type):
    conn = sqlite3.connect("mark_database.db")
    cursor = conn.cursor()

    if filter_type.lower() == "cloud":
        cursor.execute("SELECT * FROM dvds WHERE cloud IS NOT NULL AND cloud != ''")
        response_tag = "🌩 Cloud Entries"
    elif filter_type.isdigit():  
        cursor.execute("SELECT * FROM dvds WHERE disc_number = ?", (filter_type,))
        response_tag = f"💿 Disc #{filter_type}"
    else:  
        cursor.execute("SELECT * FROM dvds WHERE cloud LIKE ? OR match_listing LIKE ?", ('%' + filter_type + '%', '%' + filter_type + '%'))
        response_tag = f"📜 Results for '{filter_type}'"

    results = cursor.fetchall()
    conn.close()

    return f"\n🔍 **{response_tag}:**\n" + "\n".join(
        f"🎬 {r[3]} - {r[4]} | Cloud: {r[5]} | Disc #: {r[1]} | Matches: {r[7]}"
        for r in results
    ) if results else f"\n🛑 **Bruh, that ain't it. Try another filter.**"

# Function to fetch wrestling match results dynamically
def get_match_results(event_name):
    """
    Calls the R scraper and stores match results in SQL for future reference.
    """
    conn = sqlite3.connect("mark_database.db")
    cursor = conn.cursor()

    # Check if event is already stored
    cursor.execute("SELECT matches FROM match_results WHERE event_name = ?", (event_name,))
    result = cursor.fetchone()

    if result:
        return f"\n🎤 **Match Results for {event_name}**\n{result[0]}"

    # If not stored, scrape match results
    command = f'Rscript -e "source(\'/Users/josemarrero/MarkBot/smark_scraper.R\'); cat(scrape_event_matches(\'{event_name}\'), sep = \'\\n\')"'
    process = subprocess.run(command, shell=True, capture_output=True, text=True)
    match_data = process.stdout.strip().split("\n")

    if match_data:
        matches_text = "\n".join(match_data)

        # Store results in SQL for future lookups
        cursor.execute("INSERT INTO match_results (event_name, matches) VALUES (?, ?)", (event_name, matches_text))
        conn.commit()
        conn.close()

        return f"\n🎤 **Match Results for {event_name}**\n{matches_text}"
    
    return f"\n🛑 **No match results found for {event_name}. Try again.**"

# Randomized thug-style farewells
farewells = [
    "👊 Aight, I'm out. You handle yo' business.",
    "🚀 This convo just tapped out—ONE!",
    "🔥 Cool, but I got better things to do. Holla!",
    "💨 Mark is signing off—you deal with yo' mess."
]

# Chatbot loop with natural command detection & memory-based responses
while True:
    user_input = input("\nAsk me about wrestling data (or type 'show me Cloud', 'show me Disc #', 'show me 45A1', or a wrestling event name): ").strip()

    if user_input.lower() in ["exit", "quit"]:
        print(random.choice(farewells))
        break

    elif "matches for" in user_input or "wrestling event" in user_input:
        event_name = user_input.replace("matches for", "").replace("wrestling event", "").strip()
        print(get_match_results(event_name))

    elif user_input.lower().startswith(("filter:", "show me")):
        filter_request = user_input.split(":")[-1].strip() if "filter:" in user_input else user_input.split("show me")[-1].strip()

        if filter_request.isdigit():
            print(search_filtered_data(filter_request))
        else:
            print(search_sql_data(filter_request))

    else:
        print(search_sql_data(user_input))
